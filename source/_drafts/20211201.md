---
title: 20211201
tags:
---

## hexo创建草稿

```shell
hexo new draft <title>
```

将草稿发布为正式文章,其中 `<filename>` 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。

```shell
hexo P <filename>
```

## 关于IOU

在目标检测当中，有一个重要的概念就是 IOU。一般指代模型预测的 bbox 和 Groud Truth 之间的交并比。交并比是指两张图片交集部分与两张图片的并集部分相比的值，即(P1 ∩ P2)/(P1 ∪ P2)

计算IOU总结为：两张图片相交部分面积除以两张图片叠加后的总面积

IOU代码
```c
typedef struct
{
  int32_t x;
  int32_t y;
} mf_point_t;


/**
 * @brief 计算IOU(只考虑了两张图片不旋转的情况)
 * @details
 *                               x
 *                               |
 *                               |____ y  (注意坐标轴是颠倒的)
 *       _________B(x,y)
 *      |         |
 *      |     ____|F(x,y)___D(x,y)
 *      |    |    |         |
 *      |    |    |         |
 *      |____|____|         |
 *  A(x,y)   |E(x,y)        |
 *           |______________|
 *          C(x,y)
 * 
 * 交集：a = (B(y) - C(y)) * (D(x) - A(x))
 * 并集：b = 两个图片面积之和 - a
 * 计算IOU: res = a / b 
 * @param 
 * @return 返回IOU值
*/
static double _caculate_face_iou(face_obj_t *rgb_face, face_obj_t *ir_face)
{
    if (rgb_face == NULL || ir_face == NULL)    return 0;

    /* 坐标映射 */
    mf_point_t A = {.x = rgb_face->x1,.y = rgb_face->y1};
    mf_point_t B = {.x = rgb_face->x2,.y = rgb_face->y2};
    mf_point_t C = {.x = ir_face->x1 + 122,.y = ir_face->y1 - 124}; // 手动映射
    mf_point_t D = {.x = ir_face->x2 + 185,.y = ir_face->y2 - 65};  // 手动映射
    mf_point_t E,F;
    E.x = (C.x <= B.x && C.x >= A.x) ? C.x : A.x;
    E.y = (C.y <= B.y && C.y >= A.y) ? C.y : A.y;
    F.x = (D.x <= B.x && D.x >= A.x) ? D.x : B.x;
    F.y = (D.y <= B.y && D.y >= A.y) ? D.y : B.y;
#if 0
    printf("A:(%d,%d)  B:(%d,%d)\n", A.x, A.y, B.x, B.y);
    printf("C:(%d,%d)  D:(%d,%d)\n", C.x, C.y, D.x, D.y);
    printf("E:(%d,%d)  F:(%d,%d)\n", E.x, E.y, F.x, F.y);
#endif

    /* 交集部分 */
    int32_t a = abs(F.y - E.y) * abs(F.x - E.x);

    /* 并集部分 */
    int32_t rgb_area = abs(B.y - A.y) * abs(B.x - A.x);
    int32_t ir_area = abs(D.y - C.y) * abs(D.x - C.x);
    int32_t b = abs(rgb_area) + abs(ir_area) - a;

    /* 计算iou */
    if (b == 0 || a > b)  return 0;
    double res = (double)a / (double)b;

#if 0
    printf("IOU res: %f\n", res);
#endif
    return res;
}
```

测试IOU代码
```c
#include "mf_gui.h"
static void config_line_points_par(lv_point_t *line_points, 
                                  uint16_t x1, uint16_t y1,                                                        
                                  uint16_t x2, uint16_t y2,
                                  uint16_t x3, uint16_t y3)
{
  line_points[0].x = x1;
  line_points[0].y = y1;

  line_points[1].x = x2;
  line_points[1].y = y2;

  line_points[2].x = x3;
  line_points[2].y = y3;
}

static void del_face_frame_line(lv_obj_t **line)
{
  if (*line)
  {
    lv_obj_del(*line);
    *line = NULL;
  }
}

static int _ui_show_face_frame1(int show, uint16_t x, uint16_t y, 
                        uint16_t w, uint16_t h, lv_color_t color)
{
    static uint8_t face_frame_init = 0;
    static lv_obj_t * line1 = NULL, * line2 = NULL;
    static lv_style_t style_line;
    static lv_point_t line_points1[3] = {0};
    static lv_point_t line_points2[3] = {0};

    if (face_frame_init)
    {
        del_face_frame_line(&line1);
        del_face_frame_line(&line2);
        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, color);

        if (show)
        {
            config_line_points_par(line_points1, x, y + h, x, y, x + w, y);
            config_line_points_par(line_points2, x, y + h, x + w, y + h, x + w, y);

            /*Create a line and apply the new style*/
            line1 = lv_line_create(lv_scr_act(), NULL);
            lv_line_set_points(line1, line_points1, 3);     /*Set the points*/
            lv_obj_add_style(line1, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
            lv_obj_align(line1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);

            /*Create a line and apply the new style*/
            line2 = lv_line_create(lv_scr_act(), NULL);
            lv_line_set_points(line2, line_points2, 3);     /*Set the points*/
            lv_obj_add_style(line2, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
            lv_obj_align(line2, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);
        }
    }
    else
    {
        lv_style_init(&style_line);
        lv_style_set_line_width(&style_line, LV_STATE_DEFAULT, 5);
        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, color);
        lv_style_set_line_rounded(&style_line, LV_STATE_DEFAULT, true);
        face_frame_init = 1;
    }

    return 0;
}

static int _ui_show_face_frame2(int show, uint16_t x, uint16_t y, 
                        uint16_t w, uint16_t h, lv_color_t color)
{
    static uint8_t face_frame_init = 0;
    static lv_obj_t * line1 = NULL, * line2 = NULL;
    static lv_style_t style_line;
    static lv_point_t line_points1[3] = {0};
    static lv_point_t line_points2[3] = {0};

    if (face_frame_init)
    {
        del_face_frame_line(&line1);
        del_face_frame_line(&line2);
        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, color);

        if (show)
        {
            config_line_points_par(line_points1, x, y + h, x, y, x + w, y);
            config_line_points_par(line_points2, x, y + h, x + w, y + h, x + w, y);

            /*Create a line and apply the new style*/
            line1 = lv_line_create(lv_scr_act(), NULL);
            lv_line_set_points(line1, line_points1, 3);     /*Set the points*/
            lv_obj_add_style(line1, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
            lv_obj_align(line1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);

            /*Create a line and apply the new style*/
            line2 = lv_line_create(lv_scr_act(), NULL);
            lv_line_set_points(line2, line_points2, 3);     /*Set the points*/
            lv_obj_add_style(line2, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
            lv_obj_align(line2, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);
        }
    }
    else
    {
        lv_style_init(&style_line);
        lv_style_set_line_width(&style_line, LV_STATE_DEFAULT, 5);
        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, color);
        lv_style_set_line_rounded(&style_line, LV_STATE_DEFAULT, true);
        face_frame_init = 1;
    }

    return 0;
}

#if 0
    /* 测试代码，显示红外和可见光的人脸框，使用这里的代码需要编写_ui_show_face_frame函数才能使用，可以从gui的demo中复制 */
    _ui_show_face_frame1(1, A.y, 854 - B.x, B.y - A.y, B.x - A.x, LV_COLOR_YELLOW);
    _ui_show_face_frame2(1, C.y, 854 - D.x, D.y - C.y, D.x - C.x, LV_COLOR_GREEN); 
    mf_gui_loop();
#endif
```

```
mount -o rw,remount /dev/root
```
```
fseek(fdopen(ts->fd, "a"), SEEK_END, 0);
```

[Select函数使用参考](https://blog.csdn.net/star871016/article/details/108550363)

互斥锁简单使用

```c
#include <pthread.h>

/* 互斥锁创建 */ 
static pthread_mutex_t __mutex_lock = PTHREAD_MUTEX_INITIALIZER;

/* 互斥锁初始化 */
int _mutex_lock_init(void)
{
	return !pthread_mutex_init(&__mutex_lock, NULL);
}

/* 互斥锁加锁 */
int _mutex_lock(void)
{
	 return !pthread_mutex_lock(&__mutex_lock); 
}

/* 互斥锁加锁 */
int mf_gui_mutex_trylock(void)
{
    return !pthread_mutex_trylock(&_gui_mutex_lock); 
}

/* 互斥锁解锁 */
int _mutex_unlock(void)
{
	return !pthread_mutex_unlock(&__mutex_lock); 
}
```

```c
#include <pthread.h>
#include <sys/select.h>

static void *mf_gui_thread(void *args)
{
    int fd = -1;
    while ((fd = evdev_get_fd()) < 0);

    fd_set fds;

    while(1)
    {
        FD_ZERO(&fds);
        FD_SET(fd, &fds);
        int fd_res = select(fd + 1, &fds, NULL, NULL, NULL);
        if (fd_res > 0 && FD_ISSET(fd, &fds))
        {
            mf_gui_mutex_lock();
            mf_gui_loop();
            mf_gui_mutex_unlock();
        }
    }

    return NULL;
}

pthread_create(&gui_pthread, NULL, mf_gui_thread, NULL);
```

##### 坐标映射简单算法，833 MF5

```c
// 水平
    // {
    //     int evdev_hor = evdev_hor_max - evdev_hor_min;
    //     printf("evdev_her:%d  evdev_float:%f\n", evdev_hor,  (double)disp_hor_res / evdev_hor);
    //     data->point.x = evdev_root_x * disp_hor_res / evdev_hor;
    // }

// 垂直
    // {
    //     int evdev_ver = evdev_ver_max - evdev_ver_min;
    //     printf("evdev_ver:%d  evdev_float:%f\n", evdev_ver,  (double)disp_ver_res / evdev_ver);
    //     data->point.y = (evdev_ver_max - evdev_root_y) * disp_ver_res / evdev_ver;
    // }   

// 调试打印
    // printf("disp_hor_res:%d disp_ver_res:%d\n", disp_hor_res, disp_ver_res);
    // printf("evdev_ver_min:%d evdev_ver_max:%d\n", evdev_ver_min, evdev_ver_max);
    // printf("evdev_hor_min:%d evdev_hor_max:%d\n", evdev_hor_min, evdev_hor_max); 
```


LVGL创建一个键盘

```c
    static lv_style_t style;
    lv_style_init(&style);
    lv_style_set_image_recolor_opa(&style, LV_STATE_PRESSED, LV_OPA_30);
    lv_style_set_image_recolor(&style, LV_STATE_PRESSED, LV_COLOR_BLACK);
    lv_style_set_text_color(&style, LV_STATE_DEFAULT, LV_COLOR_WHITE);
    lv_obj_t *obj = lv_keyboard_create(lv_scr_act(), NULL);
    lv_keyboard_set_cursor_manage(obj, true);
    lv_obj_add_style(obj, LV_IMGBTN_PART_MAIN, &style);
    lv_obj_set_size(obj, 600, 140);
    lv_obj_set_pos(obj, 0, 450);
    lv_keyboard_set_mode(obj, LV_KEYBOARD_MODE_NUM);
```

MF5,MF7 IOU直接的坐标映射

```c
    mf_point_t C = {.x = ir_face->x1 + 139,.y = ir_face->y1 + 60}; // 手动映射
    mf_point_t D = {.x = ir_face->x2 + 204,.y = ir_face->y2 + 139};  // 手动映射

    double x_a = (double)1.5;
    double y_a = (double)1.5;
    mf_point_t C = {.x = ir_face->x1 * x_a + 30,.y = ir_face->y1 * y_a - 6}; // 手动映射
    mf_point_t D = {.x = ir_face->x2 * y_a + 48,.y = ir_face->y2 * y_a + 9};  // 手动映射
```

    uint8_t uid[16] = {0x41, 0x92, 0x00, 0x23};
    uint32_t id, id2;
    id =  *(uint32_t *)uid;
    printf("id:%#x\n", id);
    #define uid2id32(a) (((a)[0]) | ((a)[1] << 8) | ((a)[2] << 16) | ((a)[3] << 24))
    #define uid2id16(a) (((a)[0]) | ((a)[1] << 8))
    printf("id2:%#x\n", uid2id32(uid));
    printf("id3:%#x\n", uid2id16(uid));

#### 2021 12 07

反射弧=感受器、传入神经、中间神经元、传出神经和效应器
TODO：感受器，传入神经，传出神经，效应器

1. 解决IOU阈值被误改的问题

#### Linux字节转换
[参考](https://jason--liu.github.io/2018/02/07/cputole/)
kernel里面经常能看见下面几个函数:be32_to_cpu, cpu_to_be32, cpu_to_le16,cpu_to_le32等
1. le叫做little endian, be叫做big endian,这是两种字节序,分别称为小段和大端.
2. 凡是xx_to_cpu就说明结果是给cpu使用的.反之,cpu_to_xx就说明从cpu的字节序转换成目标字节序
3. 如果cpu本身就是小端模式,那么cput_to_le32这类函数就会do nothing

### Linux驱动中的gpio_desc结构体

```c
struct gpio_desc {
	struct gpio_device	*gdev;
	unsigned long		flags;
	/* Connection label */
	const char		*label;
	/* Name of the GPIO */
	const char		*name;
};
```
其中
1. gdev包含了gpio设备详细参数
2. flags是gpio被占用的情况
3. label保存说明
4. name保存名称

```c
struct gpio_device {
	int			id;
	struct device		dev;
	struct cdev		chrdev;
	struct device		*mockdev;
	struct module		*owner;
	struct gpio_chip	*chip;
	struct gpio_desc	*descs;
	int			base;
	u16			ngpio;
	char			*label;
	void			*data;
	struct list_head        list;
};
```
其中
1. gpio的主要操作在struct gpio_chip结构体中

##### 设计模式资料

[设计模式的C语言应用](https://bbs.huaweicloud.com/blogs/113179)

每个C文件有两个头文件，一个头文件私有，由当前类的所有成员可以访问；一个头文件公有，由当前类的所有成员和外部访问


#define LOGI(format, ...)   do {\
    printf(TERMINAL_COLOR_GREEN);\
    printf(" (%d): " format, __LINE__, ##__VA_ARGS__);\
    printf(TERMINAL_COLOR_END);\
    printf(TERMINAL_COLOR_END);\
}while(0)
// 

##### DHCPC命令

udhcpc -i eth0 -T 1 -n

1. -i 选择要发现的网络
2. -T 检测网络的间隔,单位s。默认3s
3. -n 没有检测到网络则退出

##### poll函数使用

[参考资料](https://blog.csdn.net/weixin_36332642/article/details/116822020?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.opensearchhbase&spm=1001.2101.3001.4242.1)
可以监控多个文件的数据是否可读写
基本方式：定义一个数组保存多个文件描述符，为每个文件描述符绑定需要读写事件，调用poll函数轮询这些事件

```c
// 只检测一个文件
#include <poll.h>

int fd = 3;
struct pollfd pollfds;

void test(void)
{
    // 配置
    pollfds.fd = fd;
    fds.events = POLLIN | POLLOUT;

    // 轮询检测
    while (1)
    {
        int res = poll(&pollfds, 1, 50);
        if (res > 0)
        {
            if (pollfds.fd == fd && pollfds.revents & POLLIN)
            {
                // User handle
            }
        }
    }
}
```

#### git合并多个分支
方法1：
```shell
# 分支1(当前分支):aaaa
# 分支2:bbbb
# 分支3:cccc

# 需要合并分支1和分支2，则执行以下步骤：
# 步骤1：
git rebase -i cccc      # cccc不参与合并
# 步骤2，通过vi填写命令操作：
pick bbbb               # pick表示会commit这个提交
squash aaaa             # squash表示这个commit会被合并到前一个commit
#执行:wq保存并退出
#步骤3,修改合并后的message
#步骤4，完成

#注意：如果出现操作错误，执行git rebase --abort回到合并前的状态

```

##### __attribute__

`_attribute__((constructor))`可以标记一个函数，让这个函数会在main()之前执行。
```c
// 标记函数，该函数会在main之前被执行
_attribute__((constructor)) static void pre_main(void)
{
    printf("Hello!\n");
}

// 标记函数，并赋予优先级(1~100保留？未验证)
_attribute__((constructor(101))) static void pre_main1(void)
{
    printf("Hello pre_main1!\n");
}

_attribute__((constructor(102))) static void pre_main2(void)
{
    printf("Hello pre_main2!\n");
}
```

`_attribute__((constructor))`可以标记一个函数，让这个函数在main()或exit()之后执行。使用方法类似`_attribute__((constructor))`

#### 似乎有点看头的Rust教程，点击[这里](https://rust-book.junmajinlong.com/ch1/01_expression.html)跳转

#### 前后台进程切换

```shell
    命令 &      # 让进程后台运行
    jobs        # 查看后台进程
    fg %n       # 将进程n从后台切换到前台(n是jobs看到的进程编号)
    bg %n       # 让进程n切换到后台(n是jobs看到的进程编号)
```

#### 操作系统概述
1. 准备环境
    架构：x86  CISC指令集，运行快，功耗高(为了兼容导致寄存器)
        arm  RISC指令集，运行慢，功耗低
        RISC-V 基于RISC指令集的开源指令集
    CPU：指令执行效率、数据寄存效率、指令寄存效率
    内存：32位理论支持最大4G，64位理论最大支持16EB（也就是17179869184个G），实际只用了48位，对应支持最大内存256TB
    硬盘/ROM：保存程序和其他数据
2. 启动操作系统
    步骤1：上电
    步骤2：执行BIOS。BIOS只有1M内存空间，其中0xF0000~0xFFFFF地址(64K)映射到ROM，ROM里面保存了BIOS的执行程序，程序的内容会检查一些系统硬件是否正常，以及设置中断向量表和中断服务程序，用来应对需要使用鼠标或键盘的情况，程序初始化完外设后开始启动引导扇区boot.img
    步骤3：启动引导扇区（boot.img）。boot.img保存在启动盘的第一个扇区(512K)，通常称为主引导记录扇区(MBR)。BIOS程序会将boot.img加载到内存的0x7c00地址处运行。boot.img会加载grub2的另一个镜像core.img。
    步骤4：运行core.img。core.img包括diskboot.img、lzma_decompress.img、kernel.img和各个模块对应的镜像。diskboot.img主要是加载其余的img；lzma_decompress让程序从实模式进入到保护模式，建立分段分页，内存地址扩大；kernel.img提示用户选择需要启动的操作系统
3. 操作系统初始化
    步骤1：初始化进程列表，包括0号进程、1号进程、2号进程
    步骤2：调用trap_init()，初始化中断服务和系统调用
    步骤3：调用mm_init()，初始化内存管理系统
    步骤4：调用sched_init()，初始化调度器
    步骤5：初始化VFS
    步骤6：调用kernel_init（）初始化1号进程init，这是用户态进程的祖先
    步骤7：调用kthreadd初始化2号进程，这是内核进程的祖先
4. 进程创建与运行
    步骤1：从父进程fork一个子进程，再调用exec系统调用执行子程序。exec进入内核态后调用sys_execve->do_execve->load_elf_binary来加载和执行可执行文件(ELF文件)
    步骤2：进程加入到tasks链表中随时准备运行，有几个状态来标识进程：TASK_RUNNING表示进程运行中或等待被运行中，TASK_INTERRUPTIBLE表示进程处于可中断的睡眠状态，TASK_UNINTERRUPTIBLE表示进程处于不可中断的睡眠状态，TASK_KILLABLE表示进程处于只能被KILL的状态，TASK_ZOMBIE表示进程处于僵死状态，TASK_DEAD表示进程处于结束状态。
    步骤3：维护进程的运行消息，例如进程再用户态和内核态消耗的时间、上下文的切换次数等
    步骤4：维护进程的权限控制
    步骤5：进程调度。线程和进程都在一个链表上，可以使用不同的调度算法来调度进程。其中完全公平调度的算法通过vruntime记录每个进程的运行时间，优先运行vruntime占比少的进程，CFS使用了红黑树结构，红黑树的每个节点是一个sched_entity，每个sched_entity都属于一个task_struct表示进程或线程。关于调度的4个时机：
    - 对于用户态进程，系统调用返回时，是一个被抢占的时机
    - 对于用户态进程，中断返回时，是一个被抢占的时机
    - 对于内核态，一般会用preempt_disable和preempt_enable来制造临界区让某些操作不被打断，在调用preempt_disable()时，是一个内核态代码被抢占的时机
    - 内核态中断返回时仍然是内核态，是一个被抢占的时机
5. 内存管理
    步骤1：物理内存的管理。CPU和内存的物理关系有两种：1. 对称多处理器SMP，多个CPU访问通过一个总线访问内存。2.非统一内存访问，CPU访问最近的内存。一般选择第二种方式。

    内存分布。将内存分为多个节点，每个节点用struct pglist_data表示。每个节点分多个区域，一般有ZONE_NORMAL和ZONE_MOVABLE区域，每个区域用struct zone表示。每个区域再分位多个页，每个页大小为4KB。为了方便分配页内存，将连续页作为页块，有1、2、4、8、16、32、64、128、256、512、1024共11类页块，用11个块链表包含。因此一次最大可以申请1024个连续页，对应于4MB的连续内存。每个页块的第一个页的物理地址是该页块大小的整数倍。

    swap，将长时间不使用的内存暂时写到磁盘上，成为换出。可以有效提高物理内存的利用率，一般会通过进程kswapd来完成。

    步骤2：虚拟内存的管理
    将256TB内存(以x86_64为例)分为内核空间和用户空间，用户态下内核空间仍然不能访问。在用户空间，从低位依次保存.text段,.data段,.bss段，然后是堆、内存映射段（可以将依赖的.so文件映射到内存中），最后是栈段。

    内核代码不能访问用户空间的内存。
    用户空间可以访问内核空间，但是需要加锁保护。

    步骤3：虚拟地址和物理地址的映射

    关于页表：
    |虚拟地址|物理地址|
    |-|-|
    |0x00000000|0xD0000000|
    |0x00000400|0xF0000000|

6. 文件系统
    步骤1：文件以块为单位存储，块的大小是扇区大小的整数倍，默认4K。
    步骤2：文件通过索引区索引，每个文件都有一个inode，保存了文件的读写权限、所属用户、所属组、大小、占用块数量、占用块的地址等
    步骤3：文件有缓存区
    步骤4：文件方便管理和查询
    步骤5：维护一套数据结构，保存哪些文件被进程打开和使用。
        打开文件会获得files_struct，这个结构体有文件对应的inode，可以得到file_operation来操作文件，也可以得到dentry(directory entry)来获取inode，通过inode_operations来读写磁盘的文件系统
7. 外设
    层外：硬件设备
    第1层：设备控制器，屏蔽不同硬件的差异
    第2层：驱动程序，屏蔽不同的设备控制器
    第3层：中断控制器，统一外部事件的处理
    第4层：用文件系统屏蔽驱动程序的差异
    IPC通信


##### 替换wifi账号和密码

```shell
sed 's/ssid=".*"$/ssid=\"1234\"/g' /etc/wpa_supplicant.conf

sed 's/psk=".*"$/psk=\"1234\"/g' /etc/wpa_supplicant.conf


sed -i 's/ssid=".*"$/ssid=\"1234\"/g' /etc/wpa_supplicant.conf
```

```c
void sacn_and_config_wifi(image_t *img)
{
    static uint8_t need_change_wifi_config = 1;
    uint8_t need_change_auth = 0;
    char data[256], cmd[256];

    if (need_change_wifi_config)
    {
        int num = mf_qr_scan_pic(img->addr, img->width, img->height, (uint8_t *)data, 1);
        if (num)
        {
            need_change_wifi_config = 0;

            /* 二维码识别成功 */
            printf("\n\n --- OK! QR SCAN RESULT: %s ---\n\n", data);

            cJSON* root, *sub;
            char ssid[50] = {0}, psk[50] = {0};
            root = cJSON_Parse(data);
            if(root) 
            {
#if 1
                char* json_str = cJSON_Print(root);
                if (json_str)
                {
                    printf("%s\n", json_str);
                    cJSON_free(json_str);
                }
#endif
                sub = cJSON_GetObjectItem(root, "ssid");
                strcpy(ssid, sub->valuestring);
                sub = cJSON_GetObjectItem(root, "psk");
                strcpy(psk, sub->valuestring);
                cJSON_Delete(root);
                
                printf("ssid:%s  psk:%s\n", ssid, psk);
                if (access("/", W_OK))
                {
                    need_change_auth = 1;
                    printf("/ dir is readonly, remount / to readwrite!\n");
                    system("mount -o rw,remount /");
                }

                snprintf(cmd, sizeof(cmd), "sed -i 's/ssid=\".*\"$/ssid=\"%s\"/g' /etc/wpa_supplicant.conf", ssid);
                system(cmd);
                snprintf(cmd, sizeof(cmd), "sed -i 's/psk=\".*\"$/psk=\"%s\"/g' /etc/wpa_supplicant.conf", psk);
                system(cmd);

                need_change_wifi_config = 0;
                if (need_change_auth)
                {
                    need_change_auth = 0;
                    printf("Remount / to readonly!\n");
                    system("mount -o ro,remount /");
                }
            }
            else
            {
                printf("Can't find json string\n");
            }
        }
    }
}
```

TODO:

1. UI
