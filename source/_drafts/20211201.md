---
title: 20211201
tags:
---

## hexo创建草稿

```shell
hexo new draft <title>
```

将草稿发布为正式文章,其中 `<filename>` 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。

```shell
hexo P <filename>
```

## 关于IOU

在目标检测当中，有一个重要的概念就是 IOU。一般指代模型预测的 bbox 和 Groud Truth 之间的交并比。交并比是指两张图片交集部分与两张图片的并集部分相比的值，即(P1 ∩ P2)/(P1 ∪ P2)

计算IOU总结为：两张图片相交部分面积除以两张图片叠加后的总面积

IOU代码
```c
typedef struct
{
  int32_t x;
  int32_t y;
} mf_point_t;


/**
 * @brief 计算IOU(只考虑了两张图片不旋转的情况)
 * @details
 *                               x
 *                               |
 *                               |____ y  (注意坐标轴是颠倒的)
 *       _________B(x,y)
 *      |         |
 *      |     ____|F(x,y)___D(x,y)
 *      |    |    |         |
 *      |    |    |         |
 *      |____|____|         |
 *  A(x,y)   |E(x,y)        |
 *           |______________|
 *          C(x,y)
 * 
 * 交集：a = (B(y) - C(y)) * (D(x) - A(x))
 * 并集：b = 两个图片面积之和 - a
 * 计算IOU: res = a / b 
 * @param 
 * @return 返回IOU值
*/
static double _caculate_face_iou(face_obj_t *rgb_face, face_obj_t *ir_face)
{
    if (rgb_face == NULL || ir_face == NULL)    return 0;

    /* 坐标映射 */
    mf_point_t A = {.x = rgb_face->x1,.y = rgb_face->y1};
    mf_point_t B = {.x = rgb_face->x2,.y = rgb_face->y2};
    mf_point_t C = {.x = ir_face->x1 + 122,.y = ir_face->y1 - 124}; // 手动映射
    mf_point_t D = {.x = ir_face->x2 + 185,.y = ir_face->y2 - 65};  // 手动映射
    mf_point_t E,F;
    E.x = (C.x <= B.x && C.x >= A.x) ? C.x : A.x;
    E.y = (C.y <= B.y && C.y >= A.y) ? C.y : A.y;
    F.x = (D.x <= B.x && D.x >= A.x) ? D.x : B.x;
    F.y = (D.y <= B.y && D.y >= A.y) ? D.y : B.y;
#if 0
    printf("A:(%d,%d)  B:(%d,%d)\n", A.x, A.y, B.x, B.y);
    printf("C:(%d,%d)  D:(%d,%d)\n", C.x, C.y, D.x, D.y);
    printf("E:(%d,%d)  F:(%d,%d)\n", E.x, E.y, F.x, F.y);
#endif

    /* 交集部分 */
    int32_t a = abs(F.y - E.y) * abs(F.x - E.x);

    /* 并集部分 */
    int32_t rgb_area = abs(B.y - A.y) * abs(B.x - A.x);
    int32_t ir_area = abs(D.y - C.y) * abs(D.x - C.x);
    int32_t b = abs(rgb_area) + abs(ir_area) - a;

    /* 计算iou */
    if (b == 0 || a > b)  return 0;
    double res = (double)a / (double)b;

#if 0
    printf("IOU res: %f\n", res);
#endif
    return res;
}
```

测试IOU代码
```c
#include "mf_gui.h"
static void config_line_points_par(lv_point_t *line_points, 
                                  uint16_t x1, uint16_t y1,                                                        
                                  uint16_t x2, uint16_t y2,
                                  uint16_t x3, uint16_t y3)
{
  line_points[0].x = x1;
  line_points[0].y = y1;

  line_points[1].x = x2;
  line_points[1].y = y2;

  line_points[2].x = x3;
  line_points[2].y = y3;
}

static void del_face_frame_line(lv_obj_t **line)
{
  if (*line)
  {
    lv_obj_del(*line);
    *line = NULL;
  }
}

static int _ui_show_face_frame1(int show, uint16_t x, uint16_t y, 
                        uint16_t w, uint16_t h, lv_color_t color)
{
    static uint8_t face_frame_init = 0;
    static lv_obj_t * line1 = NULL, * line2 = NULL;
    static lv_style_t style_line;
    static lv_point_t line_points1[3] = {0};
    static lv_point_t line_points2[3] = {0};

    if (face_frame_init)
    {
        del_face_frame_line(&line1);
        del_face_frame_line(&line2);
        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, color);

        if (show)
        {
            config_line_points_par(line_points1, x, y + h, x, y, x + w, y);
            config_line_points_par(line_points2, x, y + h, x + w, y + h, x + w, y);

            /*Create a line and apply the new style*/
            line1 = lv_line_create(lv_scr_act(), NULL);
            lv_line_set_points(line1, line_points1, 3);     /*Set the points*/
            lv_obj_add_style(line1, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
            lv_obj_align(line1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);

            /*Create a line and apply the new style*/
            line2 = lv_line_create(lv_scr_act(), NULL);
            lv_line_set_points(line2, line_points2, 3);     /*Set the points*/
            lv_obj_add_style(line2, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
            lv_obj_align(line2, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);
        }
    }
    else
    {
        lv_style_init(&style_line);
        lv_style_set_line_width(&style_line, LV_STATE_DEFAULT, 5);
        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, color);
        lv_style_set_line_rounded(&style_line, LV_STATE_DEFAULT, true);
        face_frame_init = 1;
    }

    return 0;
}

static int _ui_show_face_frame2(int show, uint16_t x, uint16_t y, 
                        uint16_t w, uint16_t h, lv_color_t color)
{
    static uint8_t face_frame_init = 0;
    static lv_obj_t * line1 = NULL, * line2 = NULL;
    static lv_style_t style_line;
    static lv_point_t line_points1[3] = {0};
    static lv_point_t line_points2[3] = {0};

    if (face_frame_init)
    {
        del_face_frame_line(&line1);
        del_face_frame_line(&line2);
        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, color);

        if (show)
        {
            config_line_points_par(line_points1, x, y + h, x, y, x + w, y);
            config_line_points_par(line_points2, x, y + h, x + w, y + h, x + w, y);

            /*Create a line and apply the new style*/
            line1 = lv_line_create(lv_scr_act(), NULL);
            lv_line_set_points(line1, line_points1, 3);     /*Set the points*/
            lv_obj_add_style(line1, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
            lv_obj_align(line1, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);

            /*Create a line and apply the new style*/
            line2 = lv_line_create(lv_scr_act(), NULL);
            lv_line_set_points(line2, line_points2, 3);     /*Set the points*/
            lv_obj_add_style(line2, LV_LINE_PART_MAIN, &style_line);     /*Set the points*/
            lv_obj_align(line2, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);
        }
    }
    else
    {
        lv_style_init(&style_line);
        lv_style_set_line_width(&style_line, LV_STATE_DEFAULT, 5);
        lv_style_set_line_color(&style_line, LV_STATE_DEFAULT, color);
        lv_style_set_line_rounded(&style_line, LV_STATE_DEFAULT, true);
        face_frame_init = 1;
    }

    return 0;
}

#if 0
    /* 测试代码，显示红外和可见光的人脸框，使用这里的代码需要编写_ui_show_face_frame函数才能使用，可以从gui的demo中复制 */
    _ui_show_face_frame1(1, A.y, 854 - B.x, B.y - A.y, B.x - A.x, LV_COLOR_YELLOW);
    _ui_show_face_frame2(1, C.y, 854 - D.x, D.y - C.y, D.x - C.x, LV_COLOR_GREEN); 
    mf_gui_loop();
#endif
```

```
mount -o rw,remount /dev/root
```
```
fseek(fdopen(ts->fd, "a"), SEEK_END, 0);
```

[Select函数使用参考](https://blog.csdn.net/star871016/article/details/108550363)

互斥锁简单使用

```c
/* 互斥锁创建 */ 
static pthread_mutex_t __mutex_lock = PTHREAD_MUTEX_INITIALIZER;

/* 互斥锁初始化 */
int _mutex_lock_init(void)
{
	return !pthread_mutex_init(&__mutex_lock, NULL);
}

/* 互斥锁加锁 */
int _mutex_lock(void)
{
	 return !pthread_mutex_lock(&__mutex_lock); 
}

/* 互斥锁加锁 */
int mf_gui_mutex_trylock(void)
{
    return !pthread_mutex_trylock(&_gui_mutex_lock); 
}

/* 互斥锁解锁 */
int _mutex_unlock(void)
{
	return !pthread_mutex_unlock(&__mutex_lock); 
}
```

```c
#include <pthread.h>
#include <sys/select.h>

static void *mf_gui_thread(void *args)
{
    int fd = -1;
    while ((fd = evdev_get_fd()) < 0);

    fd_set fds;

    while(1)
    {
        FD_ZERO(&fds);
        FD_SET(fd, &fds);
        int fd_res = select(fd + 1, &fds, NULL, NULL, NULL);
        if (fd_res > 0 && FD_ISSET(fd, &fds))
        {
            mf_gui_mutex_lock();
            mf_gui_loop();
            mf_gui_mutex_unlock();
        }
    }

    return NULL;
}

pthread_create(&gui_pthread, NULL, mf_gui_thread, NULL);
```

##### 坐标映射简单算法，833 MF5

```c
// 水平
    // {
    //     int evdev_hor = evdev_hor_max - evdev_hor_min;
    //     printf("evdev_her:%d  evdev_float:%f\n", evdev_hor,  (double)disp_hor_res / evdev_hor);
    //     data->point.x = evdev_root_x * disp_hor_res / evdev_hor;
    // }

// 垂直
    // {
    //     int evdev_ver = evdev_ver_max - evdev_ver_min;
    //     printf("evdev_ver:%d  evdev_float:%f\n", evdev_ver,  (double)disp_ver_res / evdev_ver);
    //     data->point.y = (evdev_ver_max - evdev_root_y) * disp_ver_res / evdev_ver;
    // }   

// 调试打印
    // printf("disp_hor_res:%d disp_ver_res:%d\n", disp_hor_res, disp_ver_res);
    // printf("evdev_ver_min:%d evdev_ver_max:%d\n", evdev_ver_min, evdev_ver_max);
    // printf("evdev_hor_min:%d evdev_hor_max:%d\n", evdev_hor_min, evdev_hor_max); 
```


LVGL创建一个键盘

```c
    static lv_style_t style;
    lv_style_init(&style);
    lv_style_set_image_recolor_opa(&style, LV_STATE_PRESSED, LV_OPA_30);
    lv_style_set_image_recolor(&style, LV_STATE_PRESSED, LV_COLOR_BLACK);
    lv_style_set_text_color(&style, LV_STATE_DEFAULT, LV_COLOR_WHITE);
    lv_obj_t *obj = lv_keyboard_create(lv_scr_act(), NULL);
    lv_keyboard_set_cursor_manage(obj, true);
    lv_obj_add_style(obj, LV_IMGBTN_PART_MAIN, &style);
    lv_obj_set_size(obj, 600, 140);
    lv_obj_set_pos(obj, 0, 450);
    lv_keyboard_set_mode(obj, LV_KEYBOARD_MODE_NUM);
```

MF5,MF7 IOU直接的坐标映射

```c
    mf_point_t C = {.x = ir_face->x1 + 139,.y = ir_face->y1 + 60}; // 手动映射
    mf_point_t D = {.x = ir_face->x2 + 204,.y = ir_face->y2 + 139};  // 手动映射

    double x_a = (double)1.5;
    double y_a = (double)1.5;
    mf_point_t C = {.x = ir_face->x1 * x_a + 30,.y = ir_face->y1 * y_a - 6}; // 手动映射
    mf_point_t D = {.x = ir_face->x2 * y_a + 48,.y = ir_face->y2 * y_a + 9};  // 手动映射
```

    uint8_t uid[16] = {0x41, 0x92, 0x00, 0x23};
    uint32_t id, id2;
    id =  *(uint32_t *)uid;
    printf("id:%#x\n", id);
    #define uid2id32(a) (((a)[0]) | ((a)[1] << 8) | ((a)[2] << 16) | ((a)[3] << 24))
    #define uid2id16(a) (((a)[0]) | ((a)[1] << 8))
    printf("id2:%#x\n", uid2id32(uid));
    printf("id3:%#x\n", uid2id16(uid));

#### 2021 12 07

反射弧=感受器、传入神经、中间神经元、传出神经和效应器
TODO：感受器，传入神经，传出神经，效应器

1. 解决IOU阈值被误改的问题

#### Linux字节转换
[参考](https://jason--liu.github.io/2018/02/07/cputole/)
kernel里面经常能看见下面几个函数:be32_to_cpu, cpu_to_be32, cpu_to_le16,cpu_to_le32等
1. le叫做little endian, be叫做big endian,这是两种字节序,分别称为小段和大端.
2. 凡是xx_to_cpu就说明结果是给cpu使用的.反之,cpu_to_xx就说明从cpu的字节序转换成目标字节序
3. 如果cpu本身就是小端模式,那么cput_to_le32这类函数就会do nothing

### Linux驱动中的gpio_desc结构体

```c
struct gpio_desc {
	struct gpio_device	*gdev;
	unsigned long		flags;
	/* Connection label */
	const char		*label;
	/* Name of the GPIO */
	const char		*name;
};
```
其中
1. gdev包含了gpio设备详细参数
2. flags是gpio被占用的情况
3. label保存说明
4. name保存名称

```c
struct gpio_device {
	int			id;
	struct device		dev;
	struct cdev		chrdev;
	struct device		*mockdev;
	struct module		*owner;
	struct gpio_chip	*chip;
	struct gpio_desc	*descs;
	int			base;
	u16			ngpio;
	char			*label;
	void			*data;
	struct list_head        list;
};
```
其中
1. gpio的主要操作在struct gpio_chip结构体中

##### 设计模式资料

[设计模式的C语言应用](https://bbs.huaweicloud.com/blogs/113179)

每个C文件有两个头文件，一个头文件私有，由当前类的所有成员可以访问；一个头文件公有，由当前类的所有成员和外部访问


#define LOGI(format, ...)   do {\
    printf(TERMINAL_COLOR_GREEN);\
    printf(" (%d): " format, __LINE__, ##__VA_ARGS__);\
    printf(TERMINAL_COLOR_END);\
    printf(TERMINAL_COLOR_END);\
}while(0)
// 

##### DHCPC命令

udhcpc -i eth0 -T 1 -n

1. -i 选择要发现的网络
2. -T 检测网络的间隔,单位s。默认3s
3. -n 没有检测到网络则退出

##### poll函数使用

[参考资料](https://blog.csdn.net/weixin_36332642/article/details/116822020?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.opensearchhbase&spm=1001.2101.3001.4242.1)
可以监控多个文件的数据是否可读写
基本方式：定义一个数组保存多个文件描述符，为每个文件描述符绑定需要读写事件，调用poll函数轮询这些事件

```c
// 只检测一个文件
#include <poll.h>

int fd = 3;
struct pollfd pollfds;

void test(void)
{
    // 配置
    pollfds.fd = fd;
    fds.events = POLLIN | POLLOUT;

    // 轮询检测
    while (1)
    {
        int res = poll(&pollfds, 1, 50);
        if (res > 0)
        {
            if (pollfds.fd == fd && pollfds.revents & POLLIN)
            {
                // User handle
            }
        }
    }
}
```

TODO:

1. UI
