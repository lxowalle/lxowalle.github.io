---
title: 杂项记录
date: 2022-11-17 21:00:26
tags:
---

# 杂项记录

这里记录一些还没有分类的日志

#### 解决zellij不能复制粘贴的问题

这个问题官网上有解释，是因为zellij只能在支持osc52命令序列的环境使用复制粘贴功能。
可以选择使用Alacritty来作为终端，并且注意粘贴的地方也需要支持osc52命令序列

如何将alacritty设置为默认终端？

```shell
# 查看alacritty的执行文件路径
whereis alacritty
# 将alacritty创建终端符号链接
sudo update-alternatives --install /usr/bin/x-terminal-emulator x-terminal-emulator /home/sipeed/.cargo/bin/alacritty 1
# 选择要使用的默认终端编号
sudo update-alternatives --config x-terminal-emulator
# 删除终端符号
sudo update-alternatives --remove x-terminal-emulator /home/sipeed/.cargo/bin/alacritty
```

#### openssl加解密

```shell
# 加密
openssl enc -e -aes-128-cbc -in input.bin -out encrypt.bin -K 112233445566778899AABBCCDDEEFF00 -iv 112233445566778899AABBCC00000000 -p -nosalt

# 解密
openssl aes-128-cbc -d -in encrypt.bin -out decode.bin -K 112233445566778899AABBCCDDEEFF00 -iv 112233445566778899AABBCC00000000 -p -nosalt
```

#### 使用v4l2-ctl检查uvc摄像头

```shell
sudo apt install v4l-utils
v4l2-ctl --list-devices
v4l2-ctl -d /dev/video0 --list-formats
```

#### C代码忽略警告检查

```c
#pragma GCC diagnostic push
#pragma GCC diagnostic warning "-Wchar-subscripts"  // 使能警告
#pragma GCC diagnostic ignored "-Wformat"           // 忽略警告
// code
// ...
#pragma GCC diagnostic pop
```


#### 在ubuntu创建桌面启动文件

```shell
# 1. 创建desktop后缀的文件
touch my_app.desktop

# 2. 写入代码
### *不添加root权限**
[Desktop Entry]
Name=MyAPP
Exec=your/path/my_app
Icon=your/path/pic_for_myapp.jpg
Terminal=false
StartupNotify=false
Type=Application

### **添加root权限**
[Desktop Entry]
Name=MyAPP
Exec=sudo your/path/my_app          # sudo
Icon=your/path/pic_for_myapp.jpg
Terminal=false
StartupNotify=false
Type=Application

# 3. 更改文件权限
sudo chown -R $USER:$USER my_app.desktop
sudo chmod +x my_app.desktop

# 4. 检查文件是否合法
desktop-file-validate my_app.desktop

# 5. 完成，双击!启动!
```

注：
> 1. 在添加sudo权限后，可以再添加-p来指定密码，但是这样不安全。
> 2. 在添加sudo权限后，可以通过visudo命令来修改/etc/sudoers文件来让该程序无需输入密码，这样更安全。修改方式：执行visudo，在打开的文件末尾添加`sipeed ALL=NOPASSWD:/home/sipeed/sipeed/tools_for_bl/flash_tool/BLDevCube`，如果不在末尾添加这段代码，则可能会被其他代码覆盖导致不生效。

#### 使用loop设备来模拟块设备

```shell
# 创建一个文件
dd if=/dev/zero of=sd_card bs=1M count=128

# 将文件转换为块设备
losetup -f                  # 1. 先找到空闲的loop设备
losetup /dev/loop15 sd_card # 2. 将空闲loop设备连接到文件

# 查看刚刚创建的块设备
lsblk | grep /dev/loop15
losetup -a

# 删除块设备(断开连接)
losetup -d /dev/loop15
```

#### Rust二进制转结构体，unsafe实现

```rust
#[repr(C)]
struct Row {
    header: [u8; 16],
    version: [u8; 8]
}

unsafe fn deserialize_row(src: Vec<u8>) ->  Row{
    std::ptr::read(src.as_ptr() as *const _)
 }

fn main(){
    unsafe {
        let row = deserialize_row(contents);
        println!("row header: {:?}", row.header);
        println!("row version: {:?}", row.version);
    }
    
}
```

#### 获取程序执行时间的简化宏
```c
// 开始
#define _TIME_BEGIN(name) uint64_t tv##name; \
        tv##name = CPU_Get_MTimer_US();

// 结束
#define _TIME_END(name) uint64_t tv2##name = CPU_Get_MTimer_US();\
        printf("[%s] exectime is %lld us, %lld ms\n", #name, tv2##name - tv##name, (tv2##name - tv##name) / 1000);
```

#### RISCV 快速阅览汇编

[RISCV 手册](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)
[RISCV 汇编伪指令](http://events.jianshu.io/p/3f7387faceef)
[RISCV 汇编特权指令](https://juejin.cn/post/6891962672892837901)

#### i2c-tools交叉编译

步骤：
1. 下载i2c-tools
2. 设置CC为交叉编译工具`export CC=/opt/toolchain-sunxi-musl/toolchain/bin/arm-openwrt-linux-gcc`
3. 在Makefile添加`USE_STATIC_LIB ?= 1`
4. 执行`make`
5. 完成，生成的指令在tools目录下
6. 使用i2c-tools调试摄像头时的记录
```shell
# 列出i2c-0的从机地址
i2cdetect -y 0      

# 设置/读取0xfe寄存器的值（对于0328，0xfe寄存器被用来设置分页）
i2cset -y -f 0 0x21 0xfe 0x01
i2cget -y -f 0 0x21 0xfe

# 获取当前的AEC所有配置，用来对照实际值（需要切换到分页1下，通过设置0xfe寄存器来切换）
i2cdump -y -f 0 0x21

# 获取/设置曝光（需要切换到分页1下，通过设置0xfe寄存器来切换）
i2cget -y -f 0 0x21 0x13
i2cset -y -f 0 0x21 0x13 0x61


# 设置页地址(只运行一次)
i2cset -y -f 0 0x21 0xfe 0x01

# 设置曝光值，下面设置的曝光值是0x61
i2cset -y -f 0 0x21 0x13 0x61
```

#### 前后台进程切换

```shell
    命令 &      # 让进程后台运行
    jobs        # 查看后台进程
    fg %n       # 将进程n从后台切换到前台(n是jobs看到的进程编号)
    bg %n       # 让进程n切换到后台(n是jobs看到的进程编号)
```


##### 让代码在main()或exit()前后执行

`_attribute__((constructor))`可以标记一个函数，让这个函数会在main()之前执行。
```c
// 标记函数，该函数会在main之前被执行(默认优先级65535)
_attribute__((constructor)) static void pre_main(void)
{
    printf("Hello!\n");
}

// 标记函数，并赋予优先级(范围0~65535，相同优先级时，先标记的函数优先执行)
_attribute__((constructor(101))) static void pre_main1(void)
{
    printf("Hello pre_main1!\n");
}

_attribute__((constructor(102))) static void pre_main2(void)
{
    printf("Hello pre_main2!\n");
}
```

`_attribute__((destructor))`可以标记一个函数，让这个函数在main()或exit()之后执行。使用方法类似`_attribute__((constructor))`

##### poll函数使用

[参考资料](https://blog.csdn.net/weixin_36332642/article/details/116822020?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.opensearchhbase&spm=1001.2101.3001.4242.1)
可以监控多个文件的数据是否可读写
基本方式：定义一个数组保存多个文件描述符，为每个文件描述符绑定需要读写事件，调用poll函数轮询这些事件

```c
// 只检测一个文件
#include <poll.h>

int fd = 3;
struct pollfd pollfds;

void test(void)
{
    // 配置
    pollfds.fd = fd;
    fds.events = POLLIN | POLLOUT;

    // 轮询检测
    while (1)
    {
        int res = poll(&pollfds, 1, 50);
        if (res > 0)
        {
            if (pollfds.fd == fd && pollfds.revents & POLLIN)
            {
                // User handle
            }
        }
    }
}
```

##### DHCPC命令

udhcpc -i eth0 -T 1 -n

1. -i 选择要发现的网络
2. -T 检测网络的间隔,单位s。默认3s
3. -n 没有检测到网络则退出

#### 互斥锁简单使用

```c
#include <pthread.h>

/* 互斥锁创建 */ 
static pthread_mutex_t __mutex_lock = PTHREAD_MUTEX_INITIALIZER;

/* 互斥锁初始化 */
int _mutex_lock_init(void)
{
	return !pthread_mutex_init(&__mutex_lock, NULL);
}

/* 互斥锁加锁 */
int _mutex_lock(void)
{
	 return !pthread_mutex_lock(&__mutex_lock); 
}

/* 互斥锁加锁 */
int mf_gui_mutex_trylock(void)
{
    return !pthread_mutex_trylock(&_gui_mutex_lock); 
}

/* 互斥锁解锁 */
int _mutex_unlock(void)
{
	return !pthread_mutex_unlock(&__mutex_lock); 
}
```

#### linux自动挂载

通过配置/etc/fstab文件来管理自动挂载。参考默认的配置项，配置有两种方式：
```shell
# 1. 使用UUID配置，UUID通过`ls -l /dev/disk/by-uuid/`查看
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults 1 1

# 2. 使用文件路径配置
sysfs /sys sysfe defaults 0 0
```
一个配置共有6个字段：
第一个字段：UUID或设备路径
第二个字段：挂载点，挂载点一定要是已经建立的空目录。
第三个字段：文件系统名称，一般默认文件系统应该是 ext4。
第四个字段：挂载参数，和mount命令的挂载参数一致。
第五个字段：指定分区是否被 dump 备份；0 代表不备份，1 代表备份，2 代表不定期备份。
第六个字段：指定分区是否被 fsck 检测；0 代表不检测，其他数字代表检测的优先级，1 的优先级比 2 高。所以先检测 1 的分区，再检测 2 的分区。一般分区的优先级是 1，其他分区的优先级是 2。


#### 用git打包patch

一般需要多方离线开发时，可用使用patch来同步分支。每个提交都会生成一个patch，当存在多个提交时，会生成多个patch

```shell
# 生成patch(注：git会对分支28e6cf2864前的所有分支差异打包patch，但不会打包分支28e6cf2864)
git format-patch 28e6cf2864

# 合并patch
git apply xxx.patch

# （可选）检查patch状态
git apply --stat xxx.patch

# （可选）检查patch是否可以被合并
git apply --check xxx.patch
```


#### rust Vec、String和&str相互转换

```rust
use std::str;

fn main() {
  // -- FROM: vec of chars --
  let src1: Vec<char> = vec!['j','{','"','i','m','m','y','"','}'];
  // to String
  let string1: String = src1.iter().collect::<String>();
  // to str
  let str1: &str = &src1.iter().collect::<String>();
  // to vec of byte
  let byte1: Vec<u8> = src1.iter().map(|c| *c as u8).collect::<Vec<_>>();
  println!("Vec<char>:{:?} | String:{:?}, str:{:?}, Vec<u8>:{:?}", src1, string1, str1, byte1);

  // -- FROM: vec of bytes --
  // in rust, this is a slice
  // b - byte, r - raw string, br - byte of raw string
  let src2: Vec<u8> = br#"e{"ddie"}"#.to_vec();
  // to String
  // from_utf8 consume the vector of bytes
  let string2: String = String::from_utf8(src2.clone()).unwrap();
  // to str
  let str2: &str = str::from_utf8(&src2).unwrap();
  // to vec of chars
  let char2: Vec<char> = src2.iter().map(|b| *b as char).collect::<Vec<_>>();
  println!("Vec<u8>:{:?} | String:{:?}, str:{:?}, Vec<char>:{:?}", src2, string2, str2, char2);

  // -- FROM: String --
  let src3: String = String::from(r#"o{"livia"}"#);
  let str3: &str = &src3;
  let char3: Vec<char> = src3.chars().collect::<Vec<_>>();
  let byte3: Vec<u8> = src3.as_bytes().to_vec();
  println!("String:{:?} | str:{:?}, Vec<char>:{:?}, Vec<u8>:{:?}", src3, str3, char3, byte3);

  // -- FROM: str --
  let src4: &str = r#"g{'race'}"#;
  let string4 = String::from(src4);
  let char4: Vec<char> = src4.chars().collect();
  let byte4: Vec<u8> = src4.as_bytes().to_vec();
  println!("str:{:?} | String:{:?}, Vec<char>:{:?}, Vec<u8>:{:?}", src4, string4, char4, byte4);
}
```

#### linux删除多余内核

系统存在多个内核,可能会需要删除多余的内核

```shell
# 1. 查看当前内核版本
uname -a

# 2. 查看已存在的内核(状态uninstal代表已经被卸载)
dpkg --get-selections | grep linux

# 3. 删除指定的内核
sudo apt remove \
linux-headers-5.15.0-52-generic \
linux-image-5.15.0-52-generic \
linux-modules-5.15.0-48-generic \
linux-headers-5.15.0-54-generic \
linux-headers-5.4.0-133 \
linux-headers-5.4.0-133-generic \
linux-hwe-5.15-headers-5.15.0-52 \
linux-hwe-5.15-headers-5.15.0-54 \
linux-image-5.15.0-52-generic \
linux-image-5.15.0-52-generic \
linux-modules-5.15.0-48-generic

# 4. 清理配置文件的记录
sudo apt purge \
linux-headers-5.15.0-52-generic \
linux-image-5.15.0-52-generic \
linux-modules-5.15.0-48-generic \
linux-headers-5.15.0-54-generic \
linux-headers-5.4.0-133 \
linux-headers-5.4.0-133-generic \
linux-hwe-5.15-headers-5.15.0-52 \
linux-hwe-5.15-headers-5.15.0-54 \
linux-image-5.15.0-52-generic \
linux-image-5.15.0-52-generic \
linux-modules-5.15.0-48-generic

# 5. 更新系统引导
sudo update-grub
```

#### 编写Readme.md

[shields.io](https://shields.io/)
[怎么写一个超棒的README文档](https://cloud.tencent.com/developer/article/1669718)

#### ubuntu上的图像处理软件

```shell
# 安装
sudo apt install gimp

# 运行
gimp
```

#### lwip初始化过程

**初始化过程**
```c
static struct dhcp netif_dhcp;
static struct autoip netif_autoip;
static struct netif *netif_default;

/* 初始化netif结构体。为了简化，有一些伪代码 */
void netif_init(void)
{
    err_t err;
    ip4_addr_t ipaddr, netmask, gw;

    /* 初始化IP地址、子网掩码和网关地址 */
    init_default_netif(&ipaddr, &netmask, &gw);

    /* 初始化一些回调 */
    netif_set_status_callback(netif_default, status_callback);
    netif_set_link_callback(netif_default, link_callback);

    /* 初始化一些结构体的空间 */
    autoip_set_struct(netif_default, &netif_autoip);
    dhcp_set_struct(netif_default, &netif_dhcp);

    /* 启动dhcp */
    dhcp_start(netif_default)
}

/* 初始化应用程序。为了简化，有一些伪代码 */
void apps_init(void)
{
    /* 请求DNS服务器进行解析域名 */
#if LWIP_DNS_APP && LWIP_DNS
    sys_timeout(5000, dns_dorequest, NULL);
#endif

    /* 创建charge服务，实现方法见lwip/contrib/apps源码 */
#if LWIP_CHARGEN_APP && LWIP_SOCKET
    chargen_init();
#endif

    /* 初始化ping服务，实现方法见lwip/contrib/apps源码 */
#if LWIP_PING_APP && LWIP_RAW && LWIP_ICMP
    ping_init(&netif_default->gw);
#endif

    /* 初始化NetBIOS服务，实现方法见lwip/contrib/apps源码 */
#if LWIP_NETBIOS_APP && LWIP_UDP
    netbiosns_init();
    netbiosns_set_name(netif_default->hostname);
#endif

    /* 初始化HTTPD服务，实现方法见lwip/src/apps源码 */
#if LWIP_HTTPD_APP && LWIP_TCP
    httpd_init();
#endif

    /* 初始化netio服务，实现方法见lwip/contrib/apps源码 */
#if LWIP_NETIO_APP && LWIP_TCP
    netio_init();
#endif

    /* 初始化rtp服务，实现方法见lwip/contrib/apps源码 */
#if LWIP_RTP_APP && LWIP_SOCKET && LWIP_IGMP
    rtp_init();
#endif

    /* 初始化udpecho服务，实现方法见lwip/contrib/apps源码 */
#if LWIP_UDPECHO_APP && LWIP_NETCONN
    udpecho_init();
#endif
}

void main(void)
{
    /* tcpip初始化 */
    tcpip_init(test_init, &init_sem);
}
```

**初始化过程使用到回调函数**
```c
/** 状态回调函数 */
static void status_callback(struct netif *state_netif)
{
    if (netif_is_up(state_netif)) {
#if LWIP_IPV4
        printf("status_callback==UP, local interface IP is %s\n", ip4addr_ntoa(netif_ip4_addr(state_netif)));
#else
        printf("status_callback==UP\n");
#endif
    } else {
        printf("status_callback==DOWN\n");
    }
}

/* 链接回调，功能？ */
static void link_callback(struct netif *state_netif)
{
    if (netif_is_link_up(state_netif)) {
        printf("link_callback==UP\n");
    } else {
        printf("link_callback==DOWN\n");
    }
}
```

**相关的网络服务：**

**chargen服务**

chargen服务运行名为字符串发生器协议的一种简单网络协议（Character Generator Protocol),设计的目的是用来调试TCP或UDP协议程序、测量连接的带宽或进行QoS的微调等。它的默认端口为19，分为基于TCP和UDP两种方式。

- TCP方式下建立连接后，服务器会不断传送任意字符到客户端，直到客户端关闭连接。
- UDP方式下每当服务器收到客户端的一个UDP数据包后，向客户端返回一个数据包，长度为0~512字节之间随机值，数据包的负载可以是任意字符。

注意：
CHARGEN协议的设计初衷是为了网络测试，并没有严格的访问控制和流量控制机制，在UDP 模式下任何人都可以向开放该服务的主机请求服务，这种简单的请求\- 回复模式便为DDoS 攻击者提供了便利


**NetBIOS服务**

NetBIOS（(Network Basic Input/Output System)严格来说它不是一个网络协议，而是一套API,为局域网内应用程序通信提供会话层（OSI七层参考模型）的支持。

NetBIOS有三种不同的实现分别为：`NetBIOS Framse(NBF)`协议、`NetBIOS over IPX/SPX (NBX)`协议、`NetBIOS over TCP/IP (NBT)`协议。前两个协议是在旧系统上的，NBF是在IEEE 802.2(数据链路层的协议)之上实现的，NBX是在IPX/SPX(与TCP/IP类似的协议)之上实现的。现在网络上的都是NBT协议，NBT自然是基于TCP/IP的。这样局域网内的一台机器除了可以用IP来标识外，也能用`NetBIOS Name`标识。

NetBIOS包括三个服务：

- `NetBIOS Name`名称注册和解析服务(使用UDP137端口)
- 为无连接通信提供数据报分发服务(使用UDP138端口)
- 为面向连接通信提供会话服务(使用UDP139端口)

**httpd服务**

httpd服务用来实现超文本传输协议（http）的服务。

**netio服务**

netio服务可以用于网络测速

**rtp服务**

RTP服务用于实现RTP（Real-time Transport Protocol）协议，RTP协议是针对多媒体数据流的一种传输层协议，详细说明了在互联网上传递音频和视频的标准数据包格式。RTP协议常用于流媒体系统（配合RTCP协议），视频会议和一键通（Push to Talk）系统（配合H.323或SIP），使它成为IP电话产业的技术基础。RTP协议和RTP控制协议（RTCP）一起使用，而且它是建立在UDP协议上的。

**udpecho**

udpecho服务用来是实现数据回传的一个服务，可以用来测试数据是否连通


#### 内核加载错误时，使用grub手动加载内核

1. 在引导界面进入grub命令行
2. 通过ls命令寻找ubuntu内核所在的磁盘。这一步目的是找到内核文件的位置，如果已经知道则可以不执行
```shell
# 直接执行ls命令会列出已发现的磁盘，格式是(磁盘号，分区号)
ls

# 使用ls命令查看分区的内容，根据文件目录是否符合linux根文件系统的格式来判断是否是linux的根文件分区
ls (hd0, 1)/
ls (hd0, 2)/
ls (hd1, 1)/
```
3. 配置根分区和启动盘

```shell
# 这里只是在当前gurb命令行里设置"/"指向的目录，方便后面查询路径
set root=(hd0, 1)
# 设置根分区及启动盘
linux /boot/vmlinuz-5.13.51-generic root=/dev/sda1
initrd /boot/initrd-img-5.13.51-generic
```

4. 启动系统

```shell
boot
```

5. 完成

注：

成功启动系统后需要立即执行`update-grub`来修复系统引导，如果linux系统有丢失，可以尝试使用`apt upgrade linux-image-generic`来获取最新的linux系统

#### 搭建本地MQTT测试环境

使用mosquitto来搭建测试MQTT的本地环境

安装和使用mosquitto
```shell
# 安装mosquitto服务和客户端
sudo apt-get install mosquitto
sudo apt-get install mosquitto-clients

# 查询/启动/停止mosquitto服务
sudo service mosquitto status       # 查看mosquitto服务状态
sudo service mosquitto start        # 启动服务
sudo service mosquitto stop         # 关闭服务

# mosquitto服务的默认配置文件在/etc/mosquitto/mosquitto.conf
# 停止mosquitto服务后，手动启动来使用自定义的配置文件
mosquitto -c my.conf
```
本地环境测试

```shell
# 关闭mosquitto服务
sudo service mosquitto stop
# 新开一个终端，手动启动mqtt服务
mosquitto -c /etc/mosquitto/mosquitto.conf -v
# 新开一个终端，模拟订阅主题topic1
mosquitto_sub -v -t topic1
# 新开一个终端，模拟向主题topic1发布消息
mosquitto_pub -v -t topic1 -m 123456
mosquitto_pub -v -t topic1 -m "hello world"
```

mosquitto配置文件

```shell
# =================================================================
# General configuration
# =================================================================

# 客户端心跳的间隔时间
#retry_interval 20

# 系统状态的刷新时间
#sys_interval 10

# 系统资源的回收时间，0表示尽快处理
#store_clean_interval 10

# 服务进程的PID
#pid_file /var/run/mosquitto.pid

# 服务进程的系统用户
#user mosquitto

# 客户端心跳消息的最大并发数
#max_inflight_messages 10

# 客户端心跳消息缓存队列
#max_queued_messages 100

# 用于设置客户端长连接的过期时间，默认永不过期
#persistent_client_expiration

# =================================================================
# Default listener
# =================================================================

# 服务绑定的IP地址
#bind_address

# 服务绑定的端口号
#port 1883

# 允许的最大连接数，-1表示没有限制
#max_connections -1

# cafile：CA证书文件
# capath：CA证书目录
# certfile：PEM证书文件
# keyfile：PEM密钥文件
#cafile
#capath
#certfile
#keyfile

# 必须提供证书以保证数据安全性
#require_certificate false

# 若require_certificate值为true，use_identity_as_username也必须为true
#use_identity_as_username false

# 启用PSK（Pre-shared-key）支持
#psk_hint

# SSL/TSL加密算法，可以使用“openssl ciphers”命令获取
# as the output of that command.
#ciphers

# =================================================================
# Persistence
# =================================================================

# 消息自动保存的间隔时间
#autosave_interval 1800

# 消息自动保存功能的开关
#autosave_on_changes false

# 持久化功能的开关
persistence true

# 持久化DB文件
#persistence_file mosquitto.db

# 持久化DB文件目录
#persistence_location /var/lib/mosquitto/

# =================================================================
# Logging
# =================================================================

# 4种日志模式：stdout、stderr、syslog、topic
# none 则表示不记日志，此配置可以提升些许性能
log_dest none

# 选择日志的级别（可设置多项）
#log_type error
#log_type warning
#log_type notice
#log_type information

# 是否记录客户端连接信息
#connection_messages true

# 是否记录日志时间
#log_timestamp true

# =================================================================
# Security
# =================================================================

# 客户端ID的前缀限制，可用于保证安全性
#clientid_prefixes

# 允许匿名用户
#allow_anonymous true

# 用户/密码文件，默认格式：username:password
#password_file

# PSK格式密码文件，默认格式：identity:key
#psk_file

# pattern write sensor/%u/data
# ACL权限配置，常用语法如下：
# 用户限制：user <username>
# 话题限制：topic [read|write] <topic>
# 正则限制：pattern write sensor/%u/data
#acl_file

# =================================================================
# Bridges
# =================================================================

# 允许服务之间使用“桥接”模式（可用于分布式部署）
#connection <name>
#address <host>[:<port>]
#topic <topic> [[[out | in | both] qos-level] local-prefix remote-prefix]

# 设置桥接的客户端ID
#clientid

# 桥接断开时，是否清除远程服务器中的消息
#cleansession false

# 是否发布桥接的状态信息
#notifications true

# 设置桥接模式下，消息将会发布到的话题地址
# $SYS/broker/connection/<clientid>/state
#notification_topic

# 设置桥接的keepalive数值
#keepalive_interval 60

# 桥接模式，目前有三种：automatic、lazy、once
#start_type automatic

# 桥接模式automatic的超时时间
#restart_timeout 30

# 桥接模式lazy的超时时间
#idle_timeout 60

# 桥接客户端的用户名
#username

# 桥接客户端的密码
#password

# bridge_cafile：桥接客户端的CA证书文件
# bridge_capath：桥接客户端的CA证书目录
# bridge_certfile：桥接客户端的PEM证书文件
# bridge_keyfile：桥接客户端的PEM密钥文件
#bridge_cafile
#bridge_capath
#bridge_certfile
#bridge_keyfile
```