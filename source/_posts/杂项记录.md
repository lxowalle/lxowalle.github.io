---
title: 杂项记录
date: 2022-11-17 21:00:26
tags:
---

# 杂项记录

这里记录一些还没有分类的日志

#### 解决zellij不能复制粘贴的问题

这个问题官网上有解释，是因为zellij只能在支持osc52信号的环境使用复制粘贴功能。
可以选择使用Alacritty来作为终端，并且注意粘贴的地方也需要支持osc52信号

如何将alacritty设置为默认终端？

```shell
# 查看alacritty的执行文件路径
whereis alacritty
# 将alacritty创建终端符号链接
sudo update-alternatives --install /usr/bin/x-terminal-emulator x-terminal-emulator /home/sipeed/.cargo/bin/alacritty 1
# 选择要使用的默认终端编号
sudo update-alternatives --config x-terminal-emulator
# 删除终端符号
sudo update-alternatives --remove x-terminal-emulator /home/sipeed/.cargo/bin/alacritty
```

#### openssl加解密

```shell
# 加密
openssl enc -e -aes-128-cbc -in input.bin -out encrypt.bin -K 112233445566778899AABBCCDDEEFF00 -iv 112233445566778899AABBCC00000000 -p -nosalt

# 解密
openssl aes-128-cbc -d -in encrypt.bin -out decode.bin -K 112233445566778899AABBCCDDEEFF00 -iv 112233445566778899AABBCC00000000 -p -nosalt
```

#### 使用v4l2-ctl检查uvc摄像头

```shell
sudo apt install v4l-utils
v4l2-ctl --list-devices
v4l2-ctl -d /dev/video0 --list-formats
```

#### C代码忽略警告检查

```c
#pragma GCC diagnostic push
#pragma GCC diagnostic warning "-Wchar-subscripts"  // 使能警告
#pragma GCC diagnostic ignored "-Wformat"           // 忽略警告
// code
// ...
#pragma GCC diagnostic pop
```


#### 在ubuntu创建桌面启动文件

```shell
# 1. 创建desktop后缀的文件
touch my_app.desktop

# 2. 写入代码
### *不添加root权限**
[Desktop Entry]
Name=MyAPP
Exec=your/path/my_app
Icon=your/path/pic_for_myapp.jpg
Terminal=false
StartupNotify=false
Type=Application

### **添加root权限**
[Desktop Entry]
Name=MyAPP
Exec=sudo your/path/my_app          # sudo
Icon=your/path/pic_for_myapp.jpg
Terminal=false
StartupNotify=false
Type=Application

# 3. 更改文件权限
sudo chown -R $USER:$USER my_app.desktop
sudo chmod +x my_app.desktop

# 4. 检查文件是否合法
desktop-file-validate my_app.desktop

# 5. 完成，双击!启动!
```

注：
> 1. 在添加sudo权限后，可以再添加-p来指定密码，但是这样不安全。
> 2. 在添加sudo权限后，可以通过visudo命令来修改/etc/sudoers文件来让该程序无需输入密码，这样更安全。修改方式：执行visudo，在打开的文件末尾添加`sipeed ALL=NOPASSWD:/home/sipeed/sipeed/tools_for_bl/flash_tool/BLDevCube`，如果不在末尾添加这段代码，则可能会被其他代码覆盖导致不生效。

#### 使用loop设备来模拟块设备

```shell
# 创建一个文件
dd if=/dev/zero of=sd_card bs=1M count=128

# 将文件转换为块设备
losetup -f                  # 1. 先找到空闲的loop设备
losetup /dev/loop15 sd_card # 2. 将空闲loop设备连接到文件

# 查看刚刚创建的块设备
lsblk | grep /dev/loop15
losetup -a

# 删除块设备(断开连接)
losetup -d /dev/loop15
```

#### Rust二进制转结构体，unsafe实现

```rust
#[repr(C)]
struct Row {
    header: [u8; 16],
    version: [u8; 8]
}

unsafe fn deserialize_row(src: Vec<u8>) ->  Row{
    std::ptr::read(src.as_ptr() as *const _)
 }

fn main(){
    unsafe {
        let row = deserialize_row(contents);
        println!("row header: {:?}", row.header);
        println!("row version: {:?}", row.version);
    }
    
}
```

#### 获取程序执行时间的简化宏
```c
// 开始
#define _TIME_BEGIN(name) uint64_t tv##name; \
        tv##name = CPU_Get_MTimer_US();

// 结束
#define _TIME_END(name) uint64_t tv2##name = CPU_Get_MTimer_US();\
        printf("[%s] exectime is %lld us, %lld ms\n", #name, tv2##name - tv##name, (tv2##name - tv##name) / 1000);
```

#### RISCV 快速阅览汇编

[RISCV 手册](http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf)
[RISCV 汇编伪指令](http://events.jianshu.io/p/3f7387faceef)
[RISCV 汇编特权指令](https://juejin.cn/post/6891962672892837901)

#### i2c-tools交叉编译

步骤：
1. 下载i2c-tools
2. 设置CC为交叉编译工具`export CC=/opt/toolchain-sunxi-musl/toolchain/bin/arm-openwrt-linux-gcc`
3. 在Makefile添加`USE_STATIC_LIB ?= 1`
4. 执行`make`
5. 完成，生成的指令在tools目录下
6. 使用i2c-tools调试摄像头时的记录
```shell
# 列出i2c-0的从机地址
i2cdetect -y 0      

# 设置/读取0xfe寄存器的值（对于0328，0xfe寄存器被用来设置分页）
i2cset -y -f 0 0x21 0xfe 0x01
i2cget -y -f 0 0x21 0xfe

# 获取当前的AEC所有配置，用来对照实际值（需要切换到分页1下，通过设置0xfe寄存器来切换）
i2cdump -y -f 0 0x21

# 获取/设置曝光（需要切换到分页1下，通过设置0xfe寄存器来切换）
i2cget -y -f 0 0x21 0x13
i2cset -y -f 0 0x21 0x13 0x61


# 设置页地址(只运行一次)
i2cset -y -f 0 0x21 0xfe 0x01

# 设置曝光值，下面设置的曝光值是0x61
i2cset -y -f 0 0x21 0x13 0x61
```

#### 前后台进程切换

```shell
    命令 &      # 让进程后台运行
    jobs        # 查看后台进程
    fg %n       # 将进程n从后台切换到前台(n是jobs看到的进程编号)
    bg %n       # 让进程n切换到后台(n是jobs看到的进程编号)
```


##### 让代码在main()或exit()前后执行

`_attribute__((constructor))`可以标记一个函数，让这个函数会在main()之前执行。
```c
// 标记函数，该函数会在main之前被执行(默认优先级65535)
_attribute__((constructor)) static void pre_main(void)
{
    printf("Hello!\n");
}

// 标记函数，并赋予优先级(范围0~65535，相同优先级时，先标记的函数优先执行)
_attribute__((constructor(101))) static void pre_main1(void)
{
    printf("Hello pre_main1!\n");
}

_attribute__((constructor(102))) static void pre_main2(void)
{
    printf("Hello pre_main2!\n");
}
```

`_attribute__((destructor))`可以标记一个函数，让这个函数在main()或exit()之后执行。使用方法类似`_attribute__((constructor))`

##### poll函数使用

[参考资料](https://blog.csdn.net/weixin_36332642/article/details/116822020?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.opensearchhbase&spm=1001.2101.3001.4242.1)
可以监控多个文件的数据是否可读写
基本方式：定义一个数组保存多个文件描述符，为每个文件描述符绑定需要读写事件，调用poll函数轮询这些事件

```c
// 只检测一个文件
#include <poll.h>

int fd = 3;
struct pollfd pollfds;

void test(void)
{
    // 配置
    pollfds.fd = fd;
    fds.events = POLLIN | POLLOUT;

    // 轮询检测
    while (1)
    {
        int res = poll(&pollfds, 1, 50);
        if (res > 0)
        {
            if (pollfds.fd == fd && pollfds.revents & POLLIN)
            {
                // User handle
            }
        }
    }
}
```

##### DHCPC命令

udhcpc -i eth0 -T 1 -n

1. -i 选择要发现的网络
2. -T 检测网络的间隔,单位s。默认3s
3. -n 没有检测到网络则退出

#### 互斥锁简单使用

```c
#include <pthread.h>

/* 互斥锁创建 */ 
static pthread_mutex_t __mutex_lock = PTHREAD_MUTEX_INITIALIZER;

/* 互斥锁初始化 */
int _mutex_lock_init(void)
{
	return !pthread_mutex_init(&__mutex_lock, NULL);
}

/* 互斥锁加锁 */
int _mutex_lock(void)
{
	 return !pthread_mutex_lock(&__mutex_lock); 
}

/* 互斥锁加锁 */
int mf_gui_mutex_trylock(void)
{
    return !pthread_mutex_trylock(&_gui_mutex_lock); 
}

/* 互斥锁解锁 */
int _mutex_unlock(void)
{
	return !pthread_mutex_unlock(&__mutex_lock); 
}
```

#### linux自动挂载

通过配置/etc/fstab文件来管理自动挂载。参考默认的配置项，配置有两种方式：
```shell
# 1. 使用UUID配置，UUID通过`ls -l /dev/disk/by-uuid/`查看
UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults 1 1

# 2. 使用文件路径配置
sysfs /sys sysfe defaults 0 0
```
一个配置共有6个字段：
第一个字段：UUID或设备路径
第二个字段：挂载点，挂载点一定要是已经建立的空目录。
第三个字段：文件系统名称，一般默认文件系统应该是 ext4。
第四个字段：挂载参数，和mount命令的挂载参数一致。
第五个字段：指定分区是否被 dump 备份；0 代表不备份，1 代表备份，2 代表不定期备份。
第六个字段：指定分区是否被 fsck 检测；0 代表不检测，其他数字代表检测的优先级，1 的优先级比 2 高。所以先检测 1 的分区，再检测 2 的分区。一般分区的优先级是 1，其他分区的优先级是 2。


#### 用git打包patch

一般需要多方离线开发时，可用使用patch来同步分支。每个提交都会生成一个patch，当存在多个提交时，会生成多个patch

```shell
# 生成patch(注：git会对分支28e6cf2864前的所有分支差异打包patch，但不会打包分支28e6cf2864)
git format-patch 28e6cf2864

# 合并patch
git apply xxx.patch

# （可选）检查patch状态
git apply --stat xxx.patch

# （可选）检查patch是否可以被合并
git apply --check xxx.patch
```