---
title: Linux内核学习-绪论
date: 2021-10-26 22:02:26
tag: Linux
categories: Linux内核学习
---

# Linux内核学习-绪论

​	虽然只是绪论，但是涉及到内容可太多了，本想着只是流水账的概述，但是就算是流水账也是很硬核，差点看不下去。

## 一、Linux版本

​	在Linux 2.5之前（包括2.5），Linux的版本号命名规则和现在的版本不同，当时是用3个数字表示版本，其中前两个数字表示版本号，最后一个数字表示发布号。版本号的第二个数字如果是奇数则表示发布版，如果是偶数则表示稳定版。而现在Linux的版本号用4个数字表示，前2个数字表示版本号，第3个数字表示发布号，第4个数字表示补丁号。

## 二、 操作系统基本概念

​	关于操作系统，就是一系列基本程序的集合，这个集合中最重要的部分叫内核，包含了系统运行的核心过程。

​	操作系统的目的被归纳为两点：

- 与硬件交互，对硬件平台的可编程部件提供服务。
- 为运行在计算机系统上的用户程序提供执行环境。

### 2.1 多用户系统

​	多用户系统是指能并发的、独立的执行分别属于两个或多个用户的若干个应用程序的计算机系统。这里包括了多个用户同时执行同一个可执行程序，通过共享内存来共用该可执行程序的操作接口。每个用户都拥有私有的操作空间，又会在执行程序时不断地竞争各种资源（CPU、内存和硬盘等）

### 2.2 用户和组

​	对于多用户系统，用户拥有唯一标识UID来标识用户，若干个用户可以归类为一组，并用一个唯一标识GID来标识这个组。

### 2.3 进程

​	进程是一个程序执行的实例，它拥有独立的运行环境，不同的进程都分配了相同内存地址区间（虚拟地址），它们都通过虚拟地址来访问内存，但是如果不同的进程访问相同地址的虚拟地址，实际上会被映射到不同的物理地址上，对于进程自认为是系统中的唯一进程。

### 2.4 内核体系结构

​	Linux提供模块来实现模块化编程的目的，模块是一个目标文件，其代码可以在运行时链接到内核，或者被内核解除链接。

​	使用模块的优点：

1. 任何模块都可以随时链接和解除链接，为了实现这一点系统程序员必须提供明确的软件接口来访问模块处理的数据，这让开发模块更加方便。
2. 模块不依赖硬件平台，例如不依赖于arm架构，x86架构。
3. 可以在被需要时链接到内核，不需要时解除链接，因此能节省很多内存。
4. 模块的目标代码被链接后，等同于静态链接内核的目标代码，因此无性能损失。

## 三、文件系统概述

​	文件系统是一大核心。

### 3.1 文件

​	文件在内核里被高度抽象了，但在用户来看，可以认为是一个树结构组成的命名空间。树结构中的所有叶子称为文件，所有非叶子节点被称为目录。

​	每个进程都拥有一个当前工作目录，一般用"."表示当前工作目录，用".."表示父目录

### 3.2 硬链接和软链接

​	文件的硬链接可以认为是等价于自身的分身。软链接则是不等价于自身的分身。硬链接的分身就是本体，软链接的分身只能索引到本体，但是无法代替本体。

### 3.3 文件类型

​	常用文件类型（ 最常用的是前3个）：

- 普通文件
- 目录
- 符号链接
- 块设备文件
- 字符设备文件
- 管道和命名管道
- 套接字

### 3.4 文件描述符和索引节点

​	除了设备文件和特殊文件系统外，其余文件都由字符序列组成，文件内容不包括任何控制信息，例如文件长度和文件结束符。文件系统处理文件的信息都包含在索引节点inode数据结构中，文件系统通过inode来标识文件。

​	受到POSIX标准的规定，文件系统必须指定以下的属性：

- 文件类型
- 文件硬链接数量
- 文件长度（byte）
- 设备标识符
- 文件系统中标识文件的索引节点号
- 文件拥有者UID
- 文件所属组的GID
- 几个时间戳（索引节点状态改变的时间，最后访问时间和最后修改时间）
- 访问权限和文件模式

### 3.5 文件访问权限和文件模式

文件有3类用户可以指定权限和模式：文件拥有者、同组的用户、其他用户

文件有3种访问权限：读、写、执行

文件有3种模式：suid、sgid、sticky

suid：当设置了suid标志位时，进程在执行该文件时会获得该文件的拥有者uid

sgid：当设置了sgid标志位时，进程在执行该文件时会获得该文件的所属组gid

sticky：当设置了 stcky标志位时，执行该文件后该文件仍然会保留在内存。

### 3.6 文件操作的调用

​	Linux内核提供通过操作文件的方式来访问底层硬件，例如open、read、close

## 四、内核概述

​	为了提供给应用程序可以运行的环境，内核实现了一组服务和对应的操作接口。

#### 4.1 进程/内核模式

​	Unix内核利用处理器的执行权限划分了两个执行状态：内核态和用户态。内核态的权限最大，处于用户态的程序不能直接访问内核数据结构或程序，但是可以通过系统调用切换到内核态来访问这些资源。这就是进程/内核模式：由内核管理进程来执行用户程序，进程必须通过系统调用才能访问内核的数据。

​	进程进入内核态的情况有：

- 进程调用系统调用

- CPU发出一个异常信号，内核代表产生异常的进程处理异常

- 外围设备产生中断信号哦，内核执行中断处理程序

- 内核线程被执行

​	内核中还有几个被称为内核线程的特权进程，内核线程有以下特点：

- 以内核态运行在内核地址空间

- 不与用户直接交互，不需要终端设备

- 在系统启动时创建，一直活跃到系统关闭

#### 4.2 进程

​	每个进程都会有一个进程描述符，它被用来包含有关进程当前状态的信息。当内核暂停进程的执行时，该进程相关的寄存器内容会被保存在进程描述符中。这些寄存器有：

- 程序计数器PC和栈指针寄存器SP
- 通用寄存器

- 浮点寄存器
- 包含CPU状态信息的处理器控制寄存器（处理器状态字）
- 跟踪进程对RAM访问的内存管理寄存器

​	当暂停的进程被恢复时，内核会将进程描述符中的字段装载到对应的CPU寄存器中。例如：PC保存了进程暂停时下一个需要执行的指令，在恢复进程时就会将该进程的进程描述符的PC值装载到PC寄存器中，进程恢复后就能紧接暂停前继续向下执行指令。

​	进程描述符还保存了进程对应各种事件的等待状态。

#### 4.3 可重入内核

​	Unix内核是可重入的，意思就是一个进程进入了内核态一直没有退出，此时另一个进程也可以进入内核态，若干个进程可以同时在内核态下执行。

​	内核控制路径：表示内核处理系统调用、异常或中断所执行的指令序列。由于内核可重入，导致每一条内核控制路径不一定是完整的，有可能出现交错执行内核控制路径的情况，这里介绍了以下的情况：

- 进程A发起系统调用，此时开启该进程的内核控制路径，但是内核认为该系统调用无法立即获得应答，内核控制路径调用调度程序来执行另一个进程，此时进程发生切换，新进程又发起系统调用。此时就出现了两个进程的内核控制路径
- 当运行一个内核控制路径时，CPU检测到了异常，内核就会挂起当前的控制路径，转而执行异常处理程序。此时一个进程拥有了两条内核控制路径。
- 当运行一个内核控制路径时，CPU检测到了中断，内核就会挂起当前的控制路径，转而执行中断处理程序。这两条内核控制路径运行在该进程的上下文中，所花费的系统时间也算在这个进程。
- 当运行一个内核控制路径时，另一个进程抢占了当前进程，并发起了系统调用，此时也会有两条内核控制路径。

#### 4.4 进程地址空间

​	每个进程都运行在它的私有地址空间。用户态的进程有私有栈、数据区和代码区。内核态的进程使用内核的数据区和代码区，但使用另外的私有栈。

​	内核控制路径（每个都与不同的进程相关）都使用自己的私有栈。

​	进程之间可以通过共享内存来共享地址空间。

​	如果同一个内存被几个用户同时使用（例如VScode），这个程序只会被装载到内存一次，该程序的指令由需要它的用户共享，但数据不共享，每个用户有各自独立的数据空间。这种共享的地址空间是内核自动完成。

​	通过mmap()系统调用可以将存放在块设备上的文件或信息映射到进程的地址空间。

#### 4.5 同步和临界区

​	一般对全局变量的安全访问通过原子操作来保证。原子操作需要保证这一次的操作只需要执行一次，例如读写1个int类型数据就是原子操作，但是读写有多个成员的结构体时，就不属于原子操作，因为对成员赋值时CPU会执行多次赋值指令。

​	同步：内核控制路径对一个变量操作时，其他内核控制路径不允许操作该变量。

​	临界区：开始执行一段代码，这段代码的执行过程不允许被任何进程打断。

#### 4.6 禁止中断

​	单处理器通常通过禁止中断来实现临界区功能，而对于多处理器，除了禁止中断，还需要使用其他的同步技术。

#### 4.7 信号量

​	信号量是与一个数据结构关联的计数器，任何访问该数据结构前都需要检查与它关联的信号量。信号量由以下组成：

- 一个整数变量

- 一个等待进程的链表

- 两个原子方法up()和down()

​	信号量初始值为1。down()会对信号量减1，如果新值为-1，则该方法会将正在运行的进程加入到这个信号量链表中，并阻塞该进程。up()会对信号量加1，如果新值大于等于0，则会激活这个信号量链表的一个或多个进程。

#### 4.8 自旋锁

​	有时候，系统不允许在不同CPU上运行的内核控制路径同时访问同一个内核数据结构，这时候通过信号量来同步是很低效的，为了检查信号量，内核必须把进程插入到信号量链表并挂起它。这些操作太费时了，因此通过自旋锁来实现。

​	自旋锁和信号量很相似，但是自旋锁没有进程链表，当发现数据结构被锁住时，自旋锁就会执行一个紧凑的循环指令直到锁打开。

​	需要注意：单处理器环境下自旋锁是无效的，因为在自旋锁锁住时，CPU一直在自旋循环，而没有机会去解锁，这就可能导致死锁。

#### 4.9 信号

​	信号是系统将系统事件通报给进程的一种机制。进程一般执行两种操作：1. 忽略该信号，2. 异步执行信号处理程序。一般情况可以自定义进程的信号处理程序来实现特定的功能。

​	SIGKILL和SIGSTOP信号不能由进程处理，也不能被进程忽略。

​	

#### 4.10 进程间通信

​	Unix内核采用了Unix System V引入的进程间通信机制：信号量、消息队列和共享内存，它们被统称为System V IPC通信。内核把它们作为IPC资源实现，PIC资源创建后需要被显式的释放。

​	信号量：这里的信号量与上面提到的信号相似，只是这里是实现进程之间通信的。

​	消息队列：消息队列允许进程通过msgsnd()将消息插入消息队列和msgget()将消息从消息队列取出。POSIX标准定义了一种基于消息队列的IPC机制，也就是POSIX消息队列，相较于System V IPC消息队列，前者提供了更简单的基于文件操作的接口。

​	共享内存：共享内存是进程之间交换数据最快的方式，依赖于内核对进程地址空间的实现。
